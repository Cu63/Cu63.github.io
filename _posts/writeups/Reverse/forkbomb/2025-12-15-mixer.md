---
title: "mixer"
date: 2025-12-15
tags: [reverse, writeup]  
categories: [Reverse]
tagline: ""
header:
  overlay_image: /assets/images/IMG_writeups/IMG_Reverse/IMG_forkbomb/forkbomb_logo.jpg
  overlay_filter: 0.5 
  overlay_color: "#fff"
  actions:
    - label: "Lab forkbomb"
      url: "https://rev-kids20.forkbomb.ru/tasks/RE2_mixer"
classes: wide
layout: single
toc: true
toc_sticky: true
toc_label: "Оглавление"
---

- [mixer](https://rev-kids20.forkbomb.ru/files/rev/new2/mixer)

# Solution

Нужно глянуть информацию о файле. Ух, все еще `ELF`:

```bash
Info:
    File name: /spbctf_rev/mixer/mixer
    Size: 16384
    File type: ELF64
    String: ELF(AMD64)
    Extension: so
    Operation system: Debian Linux(ABI: 3.2.0)
    Architecture: AMD64
    Mode: 64-bit
    Type: DYN
    Endianness: LE
```

Гляну строки:

![IMG](/assets/images/IMG_writeups/IMG_Reverse/IMG_forkbomb/IMG_mixer/1.png){: height="200" .align-center}

Чутка полезного есть. `Give me the key:` находится в `main`, поэтому с нее и начну анализ.

## Анализ `main`

Код не сложный:

```c
  int32_t main(int32_t argc, char** argv, char** envp)
  {
      puts("Give me the key: ");
      char buf[0x10c];
      fgets(&buf, 0xff, stdin);
      int32_t rax = strlen(&buf);
      buf[(uint64_t)(rax - 1)] = 0;
      char var_218[0x100];
      var_218[(uint64_t)(rax - 2)] = 0;
      modify(&buf, &var_218, rax - 1);
      
      if (strcmp(&var_218, "k_mfblobadb{udp{idp4{iaxz"))
          puts("Incorrect");
      else
          puts("Correct");
      
      return 0;
  }
```

На вход подаем ключ. Этот ключ загоняется в функцию `modify`, а далее сравнивается с `k_mfblobadb{udp{idp4{iaxz`. Пойду разбирать `modify`

## Анализ `modify`

```c
  int64_t modify(char* buf, char* key, uint32_t len)
  {
      int32_t i;
      for (i = 0; i < len; i += 1)
      {
          int32_t pos = 0;
          while ((uint64_t)pos < strlen("abcdefghijklmnopqrstuvwxyz_{}0123456789"))
          {
              if (chars_order[(uint64_t)pos] == buf[(uint64_t)i])
                  break;   
              pos += 1;
          }   
          key[(uint64_t)i] = data_402030[(uint64_t)pos];
      }   
      return i;
  }
```

Я вижу 2 цикла. Первый цикл нужен для прохода по всем символам буфера. Второй используется для поиска позиции символа из `buf` в захардкоженной последовательности. После определения позиции происходит запись символа из другой последовательности `data_402030`. В `key[i]` записывается `data_402030[pos]`. По факту это перестановочный шифр. А вот нужные нам полседовательности.

```c
char const chars_order[0x28] = "abcdefghijklmnopqrstuvwxyz_{}0123456789", 0
char const data_402030[0x28] = "wmf9slha2r}v7te_13kby8ug4c{oz5j0idp6nqx", 0
```

## Пишу декодер

Итоговая последовательность символов у нас вот такая `k_mfblobadb{udp{idp4{iaxz`. Используем алгоритм в обратном порядке.

```python
if __name__ == '__main__':
    encode = 'wmf9slha2r}v7te_13kby8ug4c{oz5j0idp6nqx'
    decode = 'abcdefghijklmnopqrstuvwxyz_{}0123456789'
    s = 'k_mfblobadb{udp{idp4{iaxz'

    print(''.join([decode[encode.find(c)] for c in s]))
```

Можно было вообще все в одну сроку засунуть. Но это уже точно не имеет смысла)

```bash
root@8e575889c4ed:/rev# python3 solver.py
spbctf{th4t_w45_345y_3h9}
```

Проверю в бинаре:

```bash
root@8e575889c4ed:/rev# ./mixer
Give me the key:
spbctf{th4t_w45_345y_3h9}
Correct
```
